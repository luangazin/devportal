- ```
  O Backstage tem várias maneiras de se autenticar no aplicativo por meio de todos os diferentes provedores de autenticação.
  ```

```
Então, temos o Google GitHub, temos uma maneira de dizer ao Backstage quem você é, mas não há uma maneira de usar essa identidade para decidir a que você tem acesso e quais ações você pode executar no aplicativo. Portanto, isso tem sido um bloqueador para alguns adotantes.
```

```
Tem sido um recurso muito solicitado pela comunidade, e uma das coisas que queríamos levar em conta é a flexibilidade do Backstage, que achamos ser um superpoder. Portanto, queremos que esse framework seja aberto para extensão. Não queremos vincular os adotantes a uma abordagem específica de autorização, como back ou back.
```

```
A estrutura usa um modelo em que todas as suas regras são definidas em um local centralizado. Estamos chamando esse lugar de Política de Autorização. Essa política é flexível, portanto, é apenas uma função assíncrona. Ele pega uma permissão e o usuário e retorna alguma decisão. Então, porque é assíncrono, você pode fazer o que precisar fazer lá, pode chamar um sistema externo.
```

```
Você pode ler do banco de dados o que for necessário para tomar essa decisão de autorização. Também é democratizado, então os autores de plugins podem integrar suporte para isso por conta própria. Sem atualizar o núcleo do Backstage, os adotantes podem adicionar suas próprias permissões e integrá-las separadamente, portanto, não precisamos iterar nessa peça. Podemos realmente construir tudo em locais independentes.
```

Tudo bem, então eu vou pular para a demo agora. Então, eu já tenho o Backstage em execução, apenas para fornecer algum contexto sobre o que fiz para configurar o aplicativo até agora. Então, executei o script do aplicativo Backstage Create usando o Postgres como banco de dados. Criei uma entidade de catálogo para mim e me adicionei à Equipe A. E também configurei o provedor de entrada do GitHub e implementei um Resolvedor de entrada para adicionar algumas declarações de propriedade ao meu token de autorização.



Portanto, a reivindicação de propriedade está apenas dizendo que tenho uma reivindicação para minha entidade de usuário e o grupo do qual sou membro apenas para mapear isso para as entidades de catálogo corretas.



Tudo bem, então isso deve parecer familiar. Esta é apenas a página de destino da Cadillac. Posso ver todos os componentes, mesmo os componentes que não possuo, posso clicar em um componente que não possuo e posso até subir e cancelar o registro, então farei isso para demonstrar que vou mostrar como seria restringir um pouco mais esse comportamento. Então, talvez não queiramos dar a todos a capacidade de cancelar o registro de um componente, então vamos passar pelo processo de configuração, então vou pular para o Vscode e começar na configuração do aplicativo para que o a primeira coisa que você precisa fazer é ativar a estrutura de autorização para que você faça isso definindo o sinalizador habilitado para permissão como true, isso está apenas dizendo à estrutura para começar a enviar solicitações de autorização agora. Ignoramos a solicitação off como uma otimização para quem não deseja usá-la e também enquanto iteramos sobre isso e não está ativado por padrão, a próxima coisa que você precisa fazer é descomentar as teclas de back-end off.



Essa é uma maneira de os back-ends se identificarem com outros back-ends, o que é necessário. Assim, a estrutura off sabe quando uma solicitação vem de um usuário versus de um servidor. Então você pode imaginar como a ingestão de catálogo em processo que precisa de alguns recursos avançados. Não queremos restringi-lo com base nas autoridades em nossa política, então usaremos o token do servidor para isso.



Ok, então deve ser isso para a configuração do aplicativo. A próxima coisa que quero fazer é mudar para o pacote de back-end e vou adicionar a permissão do plugin de volta. Este é o novo plugin de back-end que irá lidar com todas essas solicitações de autorização de outros plugins de back-end e do front-end aplicativo final.



Então, enquanto estou instalando isso, vou começar a criar o novo módulo para o plug-in de permissão.

E isso já foi integrado ao aplicativo de exemplo no repositório principal dos bastidores. Então, vou pegar esse código e copiá-lo como ponto de partida (Start Point).

Portanto, a política neste exemplo é implementada apenas em linha. Você pode fazer isso em um pacote separado e importá-lo. Ele só precisa ser alguma função ou classe que você conecta no parâmetro de política para a chamada de criação do roteador. Então isso é chamado de política Permitir todas as permissões porque é isso que ela faz. Mas vamos fazer algumas mudanças nisso.



Então vou renomeá-lo aqui. Vou chamar isso de política de demonstração.



E como isso ainda não usa nenhum dos parâmetros, vou apenas aos parâmetros da função handle. Vou apenas deletar isso e deixar o editor preencher isso para mim.



Então, como você pode ver, para esta função handle, nós pegamos uma solicitação que é uma consulta autorizada pela política. Isso contém essa permissão e algumas informações sobre o que o usuário está tentando fazer, e também recebe um objeto de usuário que é uma resposta de identidade de bastidores e que tem o token de autenticação do usuário e suas declarações. Isso também precisa ser uma função assíncrona.



Então mencionei que queria restringir o comportamento do recurso não registrado. Então, para fazer isso, vamos ver qual permissão está sendo solicitada. Então, veremos o nome da permissão da solicitação. E quando name for igual a catalog entitydelete, que é a permissão que criamos para representar essa ação de cancelamento de registro, vamos retornar uma decisão que tem apenas um resultado de deny.



E como essa política trata apenas do caso de exclusão, queremos ter um substituto para cobrir todo o resto. Então vamos manter isso permitido pelo comportamento padrão.



Tudo bem, então neste ponto a política deve negar qualquer ação para excluir entidades do catálogo e deve permitir todo o resto.



Então, vou alterá-lo de volta para o meu diretório raiz e iniciar o aplicativo novamente.



Não, eu realmente esqueci alguns outros passos. Então, criamos o módulo de permissão, mas precisamos conectá-lo ao nosso roteador de aplicativo de back-end para pularmos para o arquivo de índice de back-end e, assim como os outros plug-ins, vamos importá-lo e criar o ambiente para e então vamos conectá-lo ao roteador e há outra coisa que temos que fazer neste arquivo. Mencionei enquanto estava atualizando a configuração do aplicativo que precisamos habilitar back-end para back-end e uma das etapas para fazer isso é substituir o gerenciador de token do servidor no op.